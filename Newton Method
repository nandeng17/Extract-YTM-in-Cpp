#include "stdafx.h"
#include <iostream>
#include <cmath>

using namespace std;
//Using Bisection Method to compute ytm
//

//set functions
double computeBondPrice(double faceValue, double coupon, double ytm, int numberOfCouponPayments)
{
	double bondPrice = 0.0;

	// discount the coupon payments
	//
	for (int i = 0; i < numberOfCouponPayments; ++i)
	{
		bondPrice += coupon*faceValue / pow(1.0 + ytm, i + 1);
	}

	// discount the bond face value
	//
	bondPrice += faceValue / pow(1.0 + ytm, numberOfCouponPayments);

	return bondPrice;
}

int main()
{
	// describe the ATT 8 5/8 2031 bond as of 19970826
	//
	double bondPrice = 106.5;               // always expressed in pts (percentage of face value)
	double bondFaceValue = 1000.0;          // standard for computations
	double coupon = 8.0 + 5.0 / 8.0;          // coupon percentage
	int compoundingFrequencyPerAnnum = 2;   // US corporate bond standard
	int numberOfCouponPayments = (2031 - 1997)*compoundingFrequencyPerAnnum;

	// bisection parameters
	//
	double ytm = 0.0;
	double tolerance = 1.0e-4;
	double a = 0.0, b = 100.0, c = 0.0;     // note that starting range is from 0 to 100.0 percent.  should be fine for all bonds

											// bisection method
											//
	do {
		double fa = computeBondPrice(bondFaceValue, coupon / 100.0 / compoundingFrequencyPerAnnum,
			a / 100.0 / compoundingFrequencyPerAnnum, numberOfCouponPayments) - bondPrice / 100.0*bondFaceValue;
		double fb = computeBondPrice(bondFaceValue, coupon / 100.0 / compoundingFrequencyPerAnnum,
			b / 100.0 / compoundingFrequencyPerAnnum, numberOfCouponPayments) - bondPrice / 100.0*bondFaceValue;

		if (abs(fa) <= tolerance)
		{
			ytm = a;
			break;
		}
		else if (abs(fb) <= tolerance)
		{
			ytm = b;
			break;
		}
		else if ((fa*fb) < 0.0)
		{
			c = (a + b) / 2.0;
			double fc = computeBondPrice(bondFaceValue, coupon / 100.0 / compoundingFrequencyPerAnnum,
				c / 100.0 / compoundingFrequencyPerAnnum, numberOfCouponPayments) - bondPrice / 100.0*bondFaceValue;
			if (abs(fc) <= tolerance)
			{
				ytm = c;
				break;
			}
			if (fa*fc < 0.0) b = c;
			else a = c;
		}
		else {
			cout << "Problem:  Lower and upper bounds of the starting range does not have a root." << endl;
			return (0);
		}

	} while (true);

	cout << "The YTM computed by Bisection method is " << ytm << " %" << endl;
	

	return 0;
}
